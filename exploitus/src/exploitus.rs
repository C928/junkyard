use crate::gui::exploitus_gui::ExpMessage;
use crate::utils::user_interact::custom_print;
use crate::utils::ExpConfig;

use std::borrow::Cow;
use std::collections::VecDeque;
use std::fs;
use std::io::{stdout, Read, Write};
use std::net::{Shutdown, SocketAddr, TcpListener, TcpStream};
use std::os::unix::fs::OpenOptionsExt;
use std::path::Path;

use chrono::{DateTime, Utc};

//todo: use specific "use" inside of modules

pub mod exploit_server {
    use super::*;
    use crate::gui::exploitus_gui::ExpMessage;
    use crate::utils::gui_utils::save_http_string;
    use crate::utils::user_interact::get_input;
    use crate::DEF_LOG_FILE;
    use std::collections::VecDeque;
    use std::env::args;

    struct Response<'a> {
        date_time: DateTime<Utc>,
        contents: &'a mut String,
        length: usize,
    }

    struct Request<'a> {
        sock_addr: SocketAddr,
        date_time: DateTime<Utc>,
        http_method: &'a str,
        host: &'a str,
        path: &'a str,
        length: usize,
    }

    //todo: allow multiple log files
    //todo: better spacing between logs columns
    fn write_logs(response: &Response, request: &Request, conf_struct: &mut ExpConfig) {
        let mut fd;
        let mut action = true;
        let mut fmt = format!("[+] chosen log file: \"{}\"", conf_struct.log_file);
        custom_print(conf_struct, &*fmt, true);
        let mut tmp_file = String::from(DEF_LOG_FILE);
        if Path::new(conf_struct.log_file).exists() {
            if conf_struct.log_overwrite == 1 {
                action = false;
            } else if conf_struct.gui_mode == false && conf_struct.log_overwrite == 2 {
                fmt = format!("[+] log file \"{}\" already exists", conf_struct.log_file);
                custom_print(conf_struct, &*fmt, true);
                if conf_struct.print_type % 2 == 1 {
                    //todo try using clear instead of replace
                    'clear: loop {
                        print!("Truncate it? [y/n]: ");
                        if let Err(_) = stdout().flush() {
                            custom_print(
                                conf_struct,
                                "[-] error: flushing terminal output: log file not written",
                                false,
                            );
                        };
                        let mut input = String::new();
                        input = match get_input(&mut input, conf_struct) {
                            Some(ret) => ret,
                            None => return,
                        };
                        match &*input {
                            "y" | "yes" => break,
                            "n" | "no" => loop {
                                print!("Append it? [y/n]: ");
                                if let Err(_) = stdout().flush() {
                                    custom_print(
                                        conf_struct,
                                        "[-] error: flushing terminal output: log file not written",
                                        false,
                                    );
                                };
                                input.clear();
                                input = match get_input(&mut input, conf_struct) {
                                    Some(ret) => ret,
                                    None => return,
                                };
                                match &*input {
                                    "y" | "yes" => {
                                        action = false;
                                        break 'clear;
                                    }
                                    "n" | "no" => loop {
                                        print!("Enter new log file name (1 to 255 chars): ");
                                        if let Err(_) = stdout().flush() {
                                            custom_print(
                                                conf_struct,
                                                "[-] error: flushing terminal output: log file not written",
                                                false,
                                            );
                                        };
                                        tmp_file.clear();
                                        match get_input(&mut tmp_file, conf_struct) {
                                            Some(ret) => tmp_file = ret,
                                            None => return,
                                        }
                                        if tmp_file != "" {
                                            let length = tmp_file.len();
                                            if length == 0 || length > 255 {
                                                break;
                                            }
                                            tmp_file = tmp_file.trim().to_owned();
                                            if Path::new(&tmp_file).exists() {
                                                println!(
                                                    "[+] log file \"{}\" already exists",
                                                    tmp_file
                                                );
                                                continue 'clear;
                                            }
                                            break 'clear;
                                        }
                                    },
                                    _ => (),
                                };
                            },
                            _ => (),
                        }
                    }
                } else {
                    for i in 1..=1024 {
                        //todo: wtf ?
                        tmp_file = format!("exploitus{}.log", i);
                        if !Path::new(&tmp_file).exists() {
                            break;
                        }
                    }
                    return;
                }
            }

            //todo use one OpenOptions with action trick
            fd = match fs::OpenOptions::new()
                .create(true)
                .truncate(action)
                .append(!action)
                .mode(0o644)
                .read(true)
                .write(true)
                .open(tmp_file)
            {
                Ok(f) => f,
                Err(_) => {
                    custom_print(conf_struct, "[-] error: opening log file", false);
                    return;
                }
            };
        } else {
            fd = match fs::OpenOptions::new()
                .create_new(true)
                .mode(0o644)
                .read(true)
                .write(true)
                .open(&conf_struct.log_file)
            {
                Ok(f) => {
                    fmt = format!("[+] log file \"{}\" created", conf_struct.log_file);
                    custom_print(conf_struct, &*fmt, true);
                    f
                }
                Err(_) => {
                    custom_print(conf_struct, "[-] error: creating log file", false);
                    return;
                }
            }
        }

        if action {
            if let Err(_) = writeln!(
                fd,
                "{}",
                format!(
                    "{:<10} {:<8} {:<15} {:<15} {:<12} {:<5} {}",
                    "Date", "Time", "Sender", "Receiver", "HTTP_Method", "Path", "Length"
                )
            ) {
                custom_print(conf_struct, "[-] error: writing logs", false);
                return;
            }
        }

        if let Ok(_) = writeln!(
            fd,
            "{} {} {} {:<15} {:<12} {:<5} {}",
            request.date_time.format("%Y-%m-%d"),
            request.date_time.format("%H:%M:%S"),
            request.sock_addr,
            request.host,
            request.http_method,
            request.path,
            request.length
        ) {
            custom_print(conf_struct, "[+] request written to log file", true);
        } else {
            custom_print(conf_struct, "[-] error: writing request to log file", false);
            return;
        }

        if let Ok(_) = writeln!(
            fd,
            "{} {} {:<15} {:<12} {:<12} {:<5} {}",
            response.date_time.format("%Y-%m-%d"),
            response.date_time.format("%H:%M:%S"),
            request.host,
            request.sock_addr,
            "RESPONSE",
            "X",
            response.length
        ) {
            custom_print(
                conf_struct,
                "[+] exploitus response written to log file",
                true,
            );
        } else {
            custom_print(
                conf_struct,
                "[-] error: writing exploitus response to log file",
                false,
            );
        }
    }

    fn parse_request<'a>(
        mut request: &'a mut Request<'a>,
        request_str: &'a Cow<'a, str>,
    ) -> Option<Request<'a>> {
        let mut lines = request_str.split("\n");
        if let Some(ret) = lines.next() {
            let mut words = ret.split(" ");
            request.http_method = match words.next() {
                Some(ret2) => {
                    let http_methods: [&str; 8] = [
                        "CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT", "TRACE",
                    ];
                    if http_methods.contains(&ret2) {
                        ret2
                    } else {
                        ""
                    }
                }
                None => "",
            };

            request.path = match words.next() {
                Some(ret2) => {
                    // max size of showed URL in firefox browser
                    // it will work for all requests with all browsers
                    // except Opera and Safari. Who use those anyway ?
                    if ret2.len() <= 65536 {
                        ret2
                    } else {
                        ""
                    }
                }
                None => "",
            };

            request.host = match lines.next() {
                Some(ret2) => {
                    words = ret2.split(" ");
                    match words.nth(1) {
                        Some(ret) => {
                            let len = ret.len();
                            // max size of host name (domain name)
                            if len > 253 {
                                ""
                            } else {
                                // remove \r
                                &ret[..len - 1]
                            }
                        }
                        None => "",
                    }
                }
                None => "",
            };

            request.length = match request_str.find("\r\n\r\n") {
                Some(ret) => ret,
                None => 0,
            }
        } else {
            return None;
        }

        // debug
        // println!("Request:\n{}", &request_str[..request.length + 4]);

        //todo: clean
        Some(Request {
            sock_addr: request.sock_addr,
            date_time: request.date_time,
            http_method: request.http_method,
            host: request.host,
            path: request.path,
            length: request.length,
        })
    }

    //todo: use read_file_contents()
    fn read_response_file(conf_struct: &mut ExpConfig, response_str: &mut String) -> u8 {
        if Path::new(conf_struct.response_file).exists() {
            let mut fd = match fs::OpenOptions::new()
                .read(true)
                .open(&conf_struct.response_file)
            {
                Ok(f) => f,
                Err(_) => {
                    custom_print(conf_struct, "[-] error: opening response file", false);
                    return 1;
                }
            };
            if let Err(_) = fd.read_to_string(response_str) {
                custom_print(conf_struct, "[-] error: reading response file", false);
                return 1;
            } else {
                let fmt = format!(
                    "[+] reading response file \"{}\"",
                    conf_struct.response_file
                );
                custom_print(conf_struct, &*fmt, true);
            }
        } else {
            let fmt = format!(
                "[-] error: response file \"{}\" does not exists",
                conf_struct.response_file
            );
            custom_print(conf_struct, &*fmt, false);
            return 1;
        }

        // debug
        //println!("[+] response contents:\n{}", response_str);
        0
    }

    fn handle_client<'a>(
        mut stream: TcpStream,
        sock_addr: SocketAddr,
        date_time: DateTime<Utc>,
        conf_struct: &mut ExpConfig,
    ) -> u8 {
        let mut response = Response {
            date_time,
            contents: &mut "".to_owned(),
            length: 0,
        };

        let mut request_bytes: [u8; 4096] = [0; 4096];
        if let Err(_) = stream.read(&mut request_bytes) {
            custom_print(conf_struct, "[-] error: reading request", false);
            return 1;
        }

        let mut tmp_request = Request {
            sock_addr,
            date_time,
            http_method: "",
            host: "",
            path: "",
            length: 0,
        };

        //todo: break in multithreading =============================================
        let request_str = String::from_utf8_lossy(&request_bytes);
        if conf_struct.gui_mode {
            save_http_string(".request_file", &request_str.to_string());
        }
        //todo: =====================================================================

        let request = match parse_request(&mut tmp_request, &request_str) {
            Some(ret) => ret,
            None => {
                custom_print(conf_struct, "[-] error: parsing request failed", false);
                return 1;
            }
        };

        if read_response_file(conf_struct, &mut response.contents) == 1 {
            /*if let Err(_) = stream.shutdown(Shutdown::Both) {
                custom_print(
                    conf_struct.print_type,
                    "[-] error: shutting down connection",
                    false,
                );
            }
            */
            return 1;
        }

        response.length = response.contents.len();
        response.date_time = Utc::now();

        if let Err(_) = stream.write(response.contents.as_bytes()) {
            custom_print(conf_struct, "[-] error: writing response", false);
            return 1;
        }
        if stream.flush().is_err() {
            custom_print(conf_struct, "[-] error: flushing TCP stream", false);
        }

        if !conf_struct.no_logs {
            write_logs(&response, &request, conf_struct);
        }

        if let Err(_) = stream.shutdown(Shutdown::Both) {
            custom_print(conf_struct, "[-] error: shutting down connection", false);
            return 1;
        }

        0
    }

    pub fn start_server(conf_struct: &mut ExpConfig) -> u8 {
        let listener = TcpListener::bind(format!("127.0.0.1:{}", conf_struct.port_number));
        if let Err(_) = listener {
            custom_print(conf_struct, "[-] error: creating TCP listener", false);
            return 1;
        }

        //while (accept) todo
        custom_print(
            conf_struct,
            "[+] exploit server successfully started\n[+] waiting for request...",
            true,
        );
        match listener.unwrap().accept() {
            Ok((stream, addr)) => {
                let date_time: DateTime<Utc> = Utc::now();
                if handle_client(stream, addr, date_time, conf_struct) == 1 {
                    return 1;
                }
            }
            Err(_) => {
                custom_print(
                    conf_struct,
                    "[-] error: accepting incoming connection",
                    false,
                );
                return 1;
            }
        }

        0
    }
}

pub mod dns_exfiltrator {
    use super::ExpConfig;
    use crate::gui::exploitus_gui::ExpMessage;
    use std::collections::VecDeque;

    //todo
    pub fn start_server(conf_struct: &mut ExpConfig) -> u8 {
        0
    }
}
