use crate::gui::exploitus_gui::{ExpMessage, CONFIG_FILE};
use crate::utils::user_interact::custom_print;

use fork::{fork, Fork};
use std::collections::VecDeque;
use std::fmt::{Display, Formatter};
use std::fs::OpenOptions;
use std::io::{stdin, Read, Write};
use std::os::unix::fs::OpenOptionsExt;
use std::path::Path;
use std::process;

use crate::DEF_LOG_FILE;
use chrono::format::parse;
use std::process::Command;

//todo: find alternative to pubs
pub struct ExpConfig<'a> {
    // type of tool used -> 0: exploit server (default), 1: dns exfiltration
    pub tool_type: u8,
    // filename of response file
    pub response_file: &'a String,
    // filename of log file
    pub log_file: &'a String,
    // logs writing options
    pub log_overwrite: u8,
    // do not write logs
    pub no_logs: bool,
    // port used for listening to incoming connection
    pub port_number: u16,
    // message types printed to terminal
    pub print_type: u8,
    // detach process from terminal (GUI version)
    pub detach: bool,
    // show GUI instead of CLI based app
    pub gui_mode: bool,
    // deque to store messages (status and errors)
    pub msg_deque: &'a mut VecDeque<ExpMessage>,
    // maximum messages stored in deque
    pub deque_max_size: usize,
}

impl<'a> ExpConfig<'a> {
    //todo: add dns query or response file
    pub fn new(
        response_file: &'a mut String,
        log_file: &'a mut String,
        msg_deque: &'a mut VecDeque<ExpMessage>,
    ) -> Self {
        Self {
            tool_type: 0,
            response_file,
            log_file,
            log_overwrite: 1,
            no_logs: false,
            port_number: 1337,
            print_type: 3,
            detach: false,
            gui_mode: false,
            msg_deque,
            deque_max_size: 32,
        }
    }

    // clap? never heard of it...
    pub fn parse_args(mut self, args_vec: &'a mut Vec<String>) -> Option<ExpConfig> {
        let args_count = args_vec.len();
        if args_count < 2 {
            eprintln!("exploitus: missing response file\nTry -h or --help for more information");
            return None;
        }

        let mut arg = "";
        match &*args_vec[1] {
            "-g" | "--gui-mode" => self.gui_mode = true,
            "-e" | "--dns-exfiltrator" => self.tool_type = 1,
            ret => {
                if ret.len() <= 32 {
                    self.response_file = &args_vec[1]
                } else {
                    eprintln!("exploitus: response file name is too long (must be <= 32 chars)");
                    return None;
                }
            }
        }

        for i in 2..args_count {
            if arg != "" {
                match arg {
                    "-r" => {
                        if args_vec[i].len() <= 32 {
                            self.response_file = &args_vec[i];
                        } else {
                            eprintln!(
                                "exploitus: response file name is too long (must be <= 32 chars)"
                            );
                            return None;
                        }
                    }
                    "-l" => {
                        if args_vec[i].len() <= 32 {
                            self.log_file = &args_vec[i];
                        } else {
                            eprintln!("exploitus: log file name is too long (must be <= 32 chars)");
                            return None;
                        }
                    }
                    "-o" => match &*args_vec[i] {
                        "0" => self.log_overwrite = 0,
                        "1" => (),
                        "2" => self.log_overwrite = 2,
                        n => {
                            eprintln!(
                                "exploitus: unexpected log writing option: \"{}\"\n\
                            Try -h or --help for more information",
                                n
                            );
                            return None;
                        }
                    },
                    "-p" => match args_vec[i].parse::<u16>() {
                        Ok(ret) => {
                            if ret == 0 {
                                eprintln!("exploitus: unexpected port number: \"{}\"", ret);
                                return None;
                            } else {
                                self.port_number = ret;
                            }
                        }
                        Err(_) => {
                            eprintln!("exploitus: error parsing port number");
                            return None;
                        }
                    },
                    "-t" => {
                        match &*args_vec[i] {
                            //todo: clean
                            "0" => self.print_type = 0,
                            "1" => self.print_type = 1,
                            "2" => self.print_type = 2,
                            "3" => (),
                            n => {
                                eprintln!(
                                    "exploitus: unexpected print_type number: \"{}\"\n\
                            Try -h or --help for more information",
                                    n
                                );
                                return None;
                            }
                        }
                    }
                    _ => (),
                }
                arg = "";
                continue;
            }

            //todo: improve usage text (add exploitus description)
            //todo: add gui mode in help + verify that everything is there
            match &*args_vec[i] {
                "-h" | "--help" => {
                    format!(
                        "Usage: <response_file> [options]\n\n\
            -r or --response-file: choose response file containing prewritten http response\n\
            -d or --detach: detach to process from terminal (only available for GUI mode)\n\
            -p or --port-number: specify the port number used to listen for incoming connections (default: 1337)\n\
            -t or --print-types: choose message types printed in terminal\n\
                            0: No message at all\n\
                            1: Only status messages\n\
                            2: Only error messages\n\
                            3: Both status and error (default)\n
            -l or --log-file: choose file where logs will be written\n\
            (default: {})\n\
            -o or --log-file-overwrite: in case logs aren't disabled and an old log file with the\n\
            same name as the new one already exists: choose whether old file is:\n\
                            0: truncated\n\
                            1: appended (default)\n\
                            2: ask when writing to it\n\
            --no-logs: do not write logs\n\
            -e or --dns-exfiltrator: listen for incoming out-of-band DNS request from vulnerable web app\n",
                        DEF_LOG_FILE
                    );
                    return None;
                }

                "-p" | "--port-number" => arg = "-p",

                "-t" | "--print-types" => arg = "-t",

                "-r" | "--response-file" => arg = "-r",

                //todo: detach from terminal (default when gui_mode)
                "-d" | "--detach" => {
                    self.detach = true;
                    match fork() {
                        Ok(Fork::Parent(_child_pid)) => return None,
                        Ok(Fork::Child) => {
                            eprintln!(
                                "[+] program detached from terminal with pid {}",
                                process::id()
                            );
                        }
                        Err(_) => {
                            eprintln!(
                                "{}",
                                "exploitus: error detaching program from terminal: fork()"
                            );
                            return None;
                        }
                    }
                }

                "-l" | "--log-file" => arg = "-l",

                "-o" | "--log-file-overwrite" => arg = "-o",

                "--no-logs" => self.no_logs = true,

                "-g" | "--gui-mode" => self.gui_mode = true,

                e => {
                    eprintln!(
                        "exploitus: invalid option '{}'\nUse -h or --help for more informations",
                        e
                    );
                    return None;
                }
            }
        }

        if self.detach && self.gui_mode == false {
            self.print_type = 0;
        }

        //todo: clean
        //let a = || args_struct;
        Some(ExpConfig {
            tool_type: self.tool_type,
            response_file: self.response_file,
            log_file: self.log_file,
            log_overwrite: self.log_overwrite,
            no_logs: self.no_logs,
            port_number: self.port_number,
            print_type: self.print_type,
            detach: self.detach,
            gui_mode: self.gui_mode,
            msg_deque: self.msg_deque,
            deque_max_size: self.deque_max_size,
        })
    }
}

pub mod gui_utils {
    use super::ExpConfig;
    use crate::gui::exploitus_gui::{ExpMessage, CONFIG_FILE};
    use crate::utils::user_interact::custom_print;
    use std::collections::VecDeque;
    use std::env::args;
    use std::fs;
    use std::fs::{File, OpenOptions};
    use std::io::{Read, Seek, SeekFrom, Write};
    use std::path::Path;
    use std::ptr::write;

    //todo: remove (temporary solution)
    pub fn remove_exploitus_file(conf_struct: &mut ExpConfig, filename: &str) {
        if let Err(_) = fs::remove_file(filename) {
            let fmt = format!("[-] error: removing \"{}\" file", filename);
            custom_print(conf_struct, &*fmt, false);
        }
    }

    //todo: remove (temporary solution)
    pub fn save_msg_deque_in_file(conf_struct: &mut ExpConfig) {
        let mut fd = match OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(".msg_deque")
        {
            Ok(f) => f,
            Err(_) => {
                custom_print(conf_struct, "[-] error: opening \".msg_deque\" file", false);
                return;
            }
        };

        let mut str;
        for msg in &*conf_struct.msg_deque {
            str = match msg {
                ExpMessage::Status(str) => str,
                ExpMessage::Error(str) => str,
            };

            if let Err(_) = writeln!(fd, "{}", str) {
                custom_print(
                    conf_struct,
                    "[-] error: writing msg to \".msg_deque\" file",
                    false,
                );
                return;
            }
        }
    }

    //todo: remove (temporary solution)
    pub fn parse_msg_deque_from_vec(
        msg_deque: &mut VecDeque<ExpMessage>,
        msg_deque_vec: Vec<&str>,
    ) {
        if msg_deque_vec.is_empty() {
            return;
        }

        for msg in msg_deque_vec {
            if msg.len() > 2 {
                match &msg[0..3] {
                    //todo: added \n in save_msg_deque_...() and removed format here
                    "[+]" => msg_deque.push_back(ExpMessage::Status(format!("{msg}\n"))),
                    "[-]" => msg_deque.push_back(ExpMessage::Error(format!("{msg}\n"))),
                    _ => (),
                }
            }
        }
    }

    pub fn read_file_contents(
        conf_struct: &mut ExpConfig,
        filename: &str,
        file_contents: &mut String,
        detail: &str,
    ) -> u8 {
        if Path::new(filename).exists() {
            match fs::OpenOptions::new().read(true).open(filename) {
                Ok(mut fd) => {
                    file_contents.clear();
                    if let Err(_) = fd.read_to_string(file_contents) {
                        let fmt = format!("[-] error: reading {} file", detail);
                        custom_print(conf_struct, &*fmt, false);
                        return 1;
                    }
                }
                Err(_) => {
                    let fmt = format!("[-] error: opening {} file", detail);
                    custom_print(conf_struct, &*fmt, false);
                    return 1;
                }
            }
        } else {
            let fmt = format!("[-] error: {} file was removed", detail);
            custom_print(conf_struct, &*detail, false);
            return 1;
        }

        0
    }

    pub fn save_config_in_file(conf_struct: &mut ExpConfig) {
        let mut fd = match OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(CONFIG_FILE)
        {
            Ok(f) => f,
            Err(_) => {
                custom_print(conf_struct, "[-] error: opening args file", false);
                return;
            }
        };

        if let Err(_) = write!(
            fd,
            "{}|{}|{}|{}|{}",
            conf_struct.response_file,
            conf_struct.log_file,
            conf_struct.no_logs,
            conf_struct.port_number,
            conf_struct.print_type
        ) {
            custom_print(conf_struct, "[-] error: writing args file", false);
        }
    }

    pub fn parse_config_from_vec<'a>(
        conf_struct: &'a mut ExpConfig,
        conf_vec: Vec<&'a str>,
    ) -> Option<(&'a str, &'a str, bool, u16, u8)> {
        if conf_vec.len() != 5 || conf_vec.contains(&"") {
            custom_print(
                conf_struct,
                "[-] error: server could not start because tool configuration isn't complete",
                false,
            );
            return None;
        }

        if conf_vec[0].len() > 32 {
            custom_print(
                conf_struct,
                "[-] error: response filename is too long (must be <= 32 chars)",
                false,
            );
            return None;
        }

        if conf_vec[1].len() > 32 {
            custom_print(
                conf_struct,
                "[-] error: log filename is too long (must be <= 32 chars)",
                false,
            );
            return None;
        }

        let no_logs = match conf_vec[2] {
            "true" => true,
            "false" => false,
            _ => {
                custom_print(
                    conf_struct,
                    "[-] error: parsing log attribute from config file",
                    false,
                );
                return None;
            }
        };

        let port_number = match conf_vec[3].parse::<u16>() {
            Ok(ret) => ret,
            Err(_) => {
                custom_print(
                    conf_struct,
                    "[-] error: parsing port attribute from args file",
                    false,
                );
                return None;
            }
        };
        let print_type = match conf_vec[4].parse::<u8>() {
            Ok(ret) => ret,
            Err(_) => {
                custom_print(
                    conf_struct,
                    "[-] error: parsing printing attribute from args file",
                    false,
                );
                return None;
            }
        };

        Some((conf_vec[0], conf_vec[1], no_logs, port_number, print_type))
    }

    pub fn save_http_string(filename: &str, text: &String) -> u8 {
        //todo: possible to use other syntax to open file
        match fs::OpenOptions::new()
            .create(true)
            .truncate(true)
            .write(true)
            .open(filename)
        {
            Ok(mut fd) => {
                if let Err(_) = write!(fd, "{}", text) {
                    return 1;
                }
            }
            Err(_) => {
                return 1;
            }
        };

        0
    }

    pub fn replace_config_attribute<'a>(
        conf_struct: &mut ExpConfig,
        index: usize,
        new: String,
    ) -> Result<(), &'a str> {
        if index >= 5 {
            return Ok(());
        }

        if Path::new(CONFIG_FILE).exists() {
            let mut config_file_contents = String::new();
            match OpenOptions::new().read(true).write(true).open(CONFIG_FILE) {
                Ok(mut fd) => {
                    if let Err(_) = fd.read_to_string(&mut config_file_contents) {
                        return Err("error: reading config file");
                    }

                    let mut conf_vec: Vec<&str> = config_file_contents.split("|").collect();
                    if conf_vec.len() == 5 {
                        fd.set_len(0);
                        fd.seek(SeekFrom::Start(0));
                        conf_vec[index] = &*new;
                        if let Err(_) = write!(
                            fd,
                            "{}|{}|{}|{}|{}",
                            conf_vec[0], conf_vec[1], conf_vec[2], conf_vec[3], conf_vec[4]
                        ) {
                            return Err("error: writing config file");
                        }
                    } else {
                        return Err("error: config file was manually modified");
                    }
                }
                Err(_) => {
                    return Err("error: opening config file");
                }
            }
        } else {
            match OpenOptions::new()
                .write(true)
                .create(true)
                .truncate(true)
                .open(CONFIG_FILE)
            {
                Ok(mut fd) => {
                    let mut v = vec![
                        conf_struct.response_file.clone(),
                        conf_struct.log_file.clone(),
                        conf_struct.no_logs.to_string(),
                        conf_struct.port_number.to_string(),
                        conf_struct.print_type.to_string(),
                    ];
                    v[index] = new;
                    /*
                    match index {
                        0 => v[0] = &new,
                        1 => v[1] = &new,
                        2 => v[2] = &new,
                        3 => v[3] = &new,
                        4 => v[]
                        _ => return Ok(()),
                    }
                     */
                    if let Err(_) = write!(fd, "{}|{}|{}|{}|{}", v[0], v[1], v[2], v[3], v[4]) {
                        return Err("error: writing config file");
                    }
                }
                Err(_) => {
                    return Err("error: creating config file");
                }
            }
        }

        Ok(())
    }
}

pub mod user_interact {
    use crate::gui::exploitus_gui::ExpMessage;
    use crate::ExpConfig;
    use std::collections::VecDeque;
    use std::io::stdin;

    pub fn get_input(mut input: &mut String, conf_struct: &mut ExpConfig) -> Option<String> {
        match stdin().read_line(&mut input) {
            Ok(_) => {
                if let Some(ret) = input.trim().to_lowercase().split("\n").nth(0) {
                    return Some(ret.to_string());
                }
            }
            Err(_) => {
                custom_print(
                    conf_struct,
                    "[-] error: reading input from stdin: log file not written",
                    false,
                );
                return None;
            }
        }

        Some("".to_string())
    }

    pub fn custom_print(conf_struct: &mut ExpConfig, to_print: &str, is_status: bool) {
        if conf_struct.print_type == 0 {
            return;
        }

        if conf_struct.gui_mode {
            let len = conf_struct.msg_deque.len();
            if len >= conf_struct.deque_max_size {
                for _ in 0..len - conf_struct.deque_max_size + 1 {
                    conf_struct.msg_deque.pop_front();
                }
            }

            if is_status && conf_struct.print_type % 2 == 1 {
                conf_struct
                    .msg_deque
                    .push_back(ExpMessage::Status(to_print.to_owned()));
            } else if !is_status && conf_struct.print_type > 1 {
                conf_struct
                    .msg_deque
                    .push_back(ExpMessage::Error(to_print.to_owned()));
            }
        } else {
            if is_status && conf_struct.print_type % 2 == 1 {
                println!("{}", to_print);
            } else if !is_status && conf_struct.print_type > 1 {
                eprintln!("{}", to_print);
            }
        }
    }
}
