use crate::exploitus::{dns_exfiltrator, exploit_server};
use crate::utils::user_interact::custom_print;
use crate::utils::{gui_utils, ExpConfig};

use eframe::egui::{trace, CentralPanel, Context, Frame};
use eframe::{run_native, App, NativeOptions};

pub mod exploitus_gui {
    use super::*;
    use crate::remove_exploitus_file;
    use crate::utils::gui_utils::{
        parse_config_from_vec, parse_msg_deque_from_vec, read_file_contents,
        replace_config_attribute, save_msg_deque_in_file,
    };
    use eframe::egui;
    use eframe::egui::panel::Side;
    use eframe::egui::CursorIcon::Text;
    use eframe::egui::ImageData::Color;
    use eframe::egui::{
        Button, Color32, ComboBox, Id, Response, RichText, ScrollArea, SelectableLabel, SidePanel,
        Slider, TextBuffer, TextEdit, TopBottomPanel, Ui,
    };
    use std::borrow::Borrow;
    use std::collections::VecDeque;
    use std::fs::{File, OpenOptions};
    use std::io::Read;
    use std::ops::DerefMut;
    use std::path::Path;
    use std::{fs, thread};

    pub const CONFIG_FILE: &str = ".config";
    pub const DEF_LOG_FILE: &str = "exploitus.log";
    const DEF_RESPONSE_FILE: &str = ".response_file";
    //todo: use format macro
    const DEFAULT_RESPONSE: &str = r#"
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8


<!DOCTYPE html>
<html>
<head></head>
<body>
<h1>Exploit response<h1>
</body>
</html>

"#;
    pub enum ExpMessage {
        Status(String),
        Error(String),
    }

    struct ExpGUI {
        //conf_struct: &'a mut ExpOptions<'a>,
        response: String,
        request: String,
        config: (String, String, bool, u16, u8),
        old_config: (String, String, bool, u16, u8),
        page: u8,
        previous_page: u8,
        init: bool,
    }

    impl Default for ExpGUI {
        fn default() -> Self {
            Self {
                response: DEFAULT_RESPONSE.trim_start().to_owned(),
                request: "".to_owned(),
                config: (
                    DEF_RESPONSE_FILE.to_owned(),
                    DEF_LOG_FILE.to_owned(),
                    false,
                    1337,
                    3,
                ),
                old_config: (
                    DEF_RESPONSE_FILE.to_owned(),
                    DEF_LOG_FILE.to_owned(),
                    false,
                    1337,
                    3,
                ),
                page: 0,
                previous_page: 0,
                init: true,
            }
        }
    }

    impl App for ExpGUI {
        fn update(&mut self, ctx: &Context, frame: &mut eframe::Frame) {
            //todo first: do not create conf_struct each time update() is called -> use App::save or global or static ??
            //todo first: store msg_str to update it only when necessary ?
            //todo first: might be possible to store ExpOptions struct into ExpGUI struct (but it adds a lifetimes which is annoying)
            //let mut conf_struct = self.conf_struct;

            let mut conf_struct = ExpConfig {
                tool_type: 0,
                response_file: &DEF_RESPONSE_FILE.to_owned(),
                log_file: &DEF_LOG_FILE.to_owned(),
                log_overwrite: 1,
                no_logs: false,
                port_number: 1337,
                print_type: 3,
                detach: true,
                gui_mode: true,
                msg_deque: &mut VecDeque::new(),
                deque_max_size: 32,
            };

            if self.init {
                let mut config_file_contents = String::new();
                read_file_contents(
                    &mut conf_struct,
                    CONFIG_FILE,
                    &mut config_file_contents,
                    "configuration",
                );
                let config_vec: Vec<&str> = config_file_contents.split("|").collect();
                match parse_config_from_vec(&mut conf_struct, config_vec) {
                    Some((rf, lf, nl, pn, pt)) => {
                        self.config.0 = match rf {
                            "" | DEF_RESPONSE_FILE => DEF_RESPONSE_FILE.to_owned(),
                            rf => rf.to_owned(),
                        };

                        self.config.1 = match lf {
                            "" | DEF_LOG_FILE => DEF_LOG_FILE.to_owned(),
                            lf => lf.to_owned(),
                        };

                        self.config.2 = nl;
                        self.config.3 = pn;
                        self.config.4 = pt;
                    }
                    None => (),
                }

                read_file_contents(
                    &mut conf_struct,
                    &self.config.0,
                    &mut self.response,
                    "response file",
                );
                self.init = false;
            }

            TopBottomPanel::top("menu_bar").show(ctx, |ui| {
                ui.horizontal_wrapped(|ui| {
                    ui.visuals_mut().button_frame = false;
                    self.menu_bar_contents(ui, frame);
                });
            });

            self.update_config();
            match self.page {
                0 => self.exploit_server_page(ctx, &mut conf_struct),
                1 => self.dns_exfiltrator_page(ctx, &conf_struct),
                2 => self.tools_config_page(ctx, &mut conf_struct),
                3 => self.settings_page(ctx, &conf_struct),
                _ => (),
            }
            self.previous_page = self.page;

            TopBottomPanel::bottom("footer").show(ctx, |ui| {
                ui.vertical_centered(|ui| {
                    ui.hyperlink_to(
                        format!("(exploitus on github {})", egui::special_emojis::GITHUB),
                        "https://github.com/c928/exploitus/",
                    );
                });
            });
        }
    }

    impl ExpGUI {
        fn menu_bar_contents(&mut self, ui: &mut Ui, frame: &mut eframe::Frame) {
            //todo: define vec as const ?
            let vec: Vec<&str> = vec!["exploit server", "dns exfiltrator", "config", "settings"];
            for i in 0..vec.len() {
                if ui.button(vec[i]).clicked() {
                    self.page = i as u8;
                    //ui.separator(); //todo
                }
            }
        }

        fn update_config(&mut self) {
            if self.previous_page == 2 && self.page != 255 && self.page != 2 {
                for i in 0..5 {
                    // todo: clean -> cannot remove match because of tuple =============
                    match i {
                        0 => self.config.0 = self.old_config.0.to_owned(),
                        1 => self.config.1 = self.old_config.1.to_owned(),
                        2 => self.config.2 = self.old_config.2,
                        3 => self.config.3 = self.old_config.3,
                        4 => self.config.4 = self.old_config.4,
                        _ => (),
                    }
                    // todo: clean ====================================================
                }
            }
        }

        fn response_input(&mut self, ui: &mut Ui) {
            /*
            let mut layouter = |ui: &egui::Ui, response_input: &str, wrap_width: f32| {
                let mut layout_job = high....
            }
            */
            ui.add(
                TextEdit::multiline(&mut self.response)
                    .desired_width(f32::INFINITY)
                    .desired_rows(24)
                    .font(egui::TextStyle::Monospace),
                //.layouter() //todo
            );
        }

        fn request_preview(&mut self, ui: &mut Ui) {
            ui.add(
                TextEdit::multiline(&mut self.request)
                    .desired_width(f32::INFINITY)
                    .desired_rows(24)
                    .font(egui::TextStyle::Monospace)
                    .interactive(false),
            );
        }

        fn exploit_server_page(&mut self, ctx: &Context, conf_struct: &mut ExpConfig) {
            CentralPanel::default().show(ctx, |mut ui| {
                //todo: remove (temporary solution) =======================================
                let mut msg_deque_str = String::new();
                if read_file_contents(
                    conf_struct,
                    ".msg_deque",
                    &mut msg_deque_str,
                    "exploit messages",
                ) == 0
                {
                    let msg_deque_vec: Vec<&str> = msg_deque_str.split("\n").collect();
                    parse_msg_deque_from_vec(conf_struct.msg_deque, msg_deque_vec);
                }
                //todo: ===================================================================

                ui.label("Write custom HTTP response to exploit vulnerable web application");
                ui.separator();
                ui.columns(2, |columns| {
                    columns[0].heading("HTTP Response Editor");
                    columns[1].heading("HTTP Request Preview");
                });

                //todo: write this above
                ui.columns(2, |columns| {
                    ScrollArea::vertical()
                        .id_source("response_input")
                        .show(&mut columns[0], |ui| self.response_input(ui));
                    ScrollArea::vertical()
                        .id_source("request_preview")
                        .show(&mut columns[1], |ui| self.request_preview(ui));
                });

                ui.columns(2, |columns| {
                    if columns[0].button(RichText::new("Write File")).clicked() {
                        if gui_utils::save_http_string(DEF_RESPONSE_FILE, &self.response) == 1 {
                            custom_print(conf_struct, "[-] error: writing response file", false);
                        } else {
                            let fmt = format!("[+] new HTTP response has been saved");
                            custom_print(conf_struct, &*fmt, true);
                        }
                    }
                    if columns[0]
                        .button(RichText::new("Start Server").color(Color32::GREEN))
                        .clicked()
                    {
                        //thread::spawn(|| {
                        let mut tmp_conf = ExpConfig {
                            tool_type: 0,
                            response_file: &DEF_RESPONSE_FILE.to_owned(),
                            log_file: &self.config.1,
                            log_overwrite: 1, //todo: config argument
                            no_logs: self.config.2,
                            port_number: self.config.3,
                            print_type: self.config.4,
                            detach: true,
                            gui_mode: true,
                            msg_deque: &mut VecDeque::new(),
                            deque_max_size: 32,
                        };
                        //todo first: fix empty response_file if not specified as program argument
                        //todo: output errors in red (ui.colored_label...)
                        if exploit_server::start_server(&mut tmp_conf) == 1 {
                            //todo: tmp comment
                            custom_print(
                                conf_struct,
                                "[-] error: exploit server failed to start",
                                false,
                            );
                        }
                        //});
                        //todo first: pass conf_struct msg_deque as function argument of start_server to show msg in real time
                        //todo: tmp comment
                        for msg in tmp_conf.msg_deque {
                            match msg {
                                ExpMessage::Status(str) => conf_struct
                                    .msg_deque
                                    .push_back(ExpMessage::Status(str.to_owned())),
                                ExpMessage::Error(str) => conf_struct
                                    .msg_deque
                                    .push_back(ExpMessage::Error(str.to_owned())),
                            }
                        }

                        read_file_contents(
                            conf_struct,
                            ".request_file",
                            &mut self.request,
                            "request",
                        );
                    }
                });

                //todo: modify so that logs are not hidden when messages are disabled
                if self.config.4 != 0 {
                    ui.columns(2, |columns| {
                        //todo: possible to use once?
                        columns[0].heading("Exploitus Messages");
                        columns[1].heading("Exploit Server Logs");
                    });
                    ui.columns(2, |columns| {
                        ScrollArea::vertical().id_source("exploitus_messages").show(
                            &mut columns[0],
                            |ui| {
                                self.show_exploitus_messages(ui, conf_struct);
                            },
                        );
                        ScrollArea::vertical()
                            .id_source("exploit_server_logs")
                            .show(&mut columns[1], |ui| {
                                self.show_logs_messages(ui, conf_struct)
                            });
                    });
                    ui.columns(2, |columns| {
                        if columns[0].add(Button::new("Clear Messages")).clicked() {
                            conf_struct.msg_deque.clear();
                        }
                    });
                }
            });

            save_msg_deque_in_file(conf_struct);
        }

        fn dns_exfiltrator_page(&mut self, ctx: &Context, conf_struct: &ExpConfig) {
            CentralPanel::default().show(ctx, |ui| {
                ui.label("coming soon ^^");
            });
        }

        fn tools_config_page(&mut self, ctx: &Context, conf_struct: &mut ExpConfig) {
            CentralPanel::default().show(ctx, |ui| {
                if self.page != self.previous_page && self.previous_page != 255 {
                    self.old_config = (
                        self.config.0.to_owned(),
                        self.config.1.to_owned(),
                        self.config.2,
                        self.config.3,
                        self.config.4,
                    );
                }
                ui.heading("Tools Configurations");
                ui.add_space(5f32);
                ui.separator();
                ui.add_space(2f32);
                ui.heading(RichText::new("Exploit Server").size(18f32));

                ui.add_space(5f32);
                ui.label("Response file");
                ui.add(TextEdit::singleline(&mut self.config.0));
                ui.add_space(5f32);

                self.config.2 = !self.config.2;
                ui.checkbox(&mut self.config.2, "Write logs");

                ui.add_space(5f32);
                if self.config.2 {
                    ui.add(TextEdit::singleline(&mut self.config.1));
                } /* else {
                      ui.add(TextEdit::singleline(RichText::new(&mut lf).color(Color32::from_rgb(128, 128, 128))).interactive(false));
                  } */
                self.config.2 = !self.config.2;

                ui.add_space(5f32);
                ui.label("Port Number");
                ui.add(Slider::new(&mut self.config.3, 0..=u16::MAX));

                //todo: add ComboBox label on top instead of right side
                //todo: add as global const? making module for all global const ?
                const PRINT_TYPES: [&str; 4] = ["No message", "Only Status", "Only Errors", "All"];
                let mut selected = self.config.4 as usize;
                ui.add_space(5f32);
                ComboBox::from_label("Exploitus Messages Types").show_index(
                    ui,
                    &mut selected,
                    PRINT_TYPES.len(),
                    |i| PRINT_TYPES[i].to_owned(),
                );
                self.config.4 = selected as u8;

                ui.separator();
                ui.heading(RichText::new("DNS Exfiltrator\n....settings....").size(18f32));

                if ui.button("Save Config").clicked() {
                    //todo: use read_file_contents function but without custom_print to print error in red
                    let mut config_file_contents = String::new();
                    if Path::new(CONFIG_FILE).exists() {
                        match fs::OpenOptions::new().read(true).open(CONFIG_FILE) {
                            Ok(mut fd) => {
                                if let Err(_) = fd.read_to_string(&mut config_file_contents) {
                                    ui.label(
                                        RichText::new("error: reading configuration file")
                                            .color(Color32::RED),
                                    );
                                }
                            }
                            Err(_) => {
                                ui.label(
                                    RichText::new("error: opening configuration file")
                                        .color(Color32::RED),
                                );
                            }
                        }
                        let config_vec: Vec<&str> = config_file_contents.split("|").collect();
                        match parse_config_from_vec(conf_struct, config_vec) {
                            Some((rf, lf, mut nl, mut pn, pt)) => {
                                let mut rf_str = rf.to_owned();
                                let mut lf_str = lf.to_owned();
                                let nl = nl.to_string();
                                let pn = pn.to_string();
                                let pt = pt.to_string();

                                let mut index = 0;
                                let mut replace =
                                    |ui: &mut Ui, new: &String, old: &String| -> bool {
                                        index += 1;
                                        if new != old {
                                            if let Err(e) = replace_config_attribute(
                                                conf_struct,
                                                index - 1,
                                                new.clone(),
                                            ) {
                                                //todo: test error red printing
                                                ui.label(RichText::new(e).color(Color32::RED));
                                                return false;
                                            }
                                        } else {
                                            return false;
                                        }
                                        return true;
                                    };
                                //todo clean: cannot use for loop because of tuple :( ============
                                if replace(ui, &self.config.0, &rf_str) {
                                    self.old_config.0 = self.config.0.to_owned();
                                }
                                if replace(ui, &self.config.1, &lf_str) {
                                    self.old_config.1 = self.config.1.to_owned();
                                }
                                if replace(ui, &self.config.2.to_string(), &nl) {
                                    self.old_config.2 = self.config.2.to_owned();
                                }
                                if replace(ui, &self.config.3.to_string(), &pn) {
                                    self.old_config.3 = self.config.3.to_owned();
                                }
                                if replace(ui, &self.config.4.to_string(), &pt) {
                                    self.old_config.4 = self.config.4.to_owned();
                                }
                                //todo clean: =========================================================
                            }
                            None => (),
                        }
                    } else {
                        ui.label(
                            RichText::new("error: configuration file was deleted")
                                .color(Color32::RED),
                        );
                    }
                }

                self.update_config();
            });
        }

        fn settings_page(&mut self, ctx: &Context, conf_struct: &ExpConfig) {
            CentralPanel::default().show(ctx, |ui| {
                ui.heading("Settings");
                ui.separator();
                //ui.spacing();
                ui.label("Theme");
                egui::widgets::global_dark_light_mode_buttons(ui);
            });
        }

        fn show_exploitus_messages(&mut self, ui: &mut Ui, conf_struct: &ExpConfig) {
            let mut msg_str = String::new();
            for msg in &*conf_struct.msg_deque {
                //todo: red color when error msg
                match msg {
                    ExpMessage::Status(str) => {
                        if self.config.4 % 2 == 1 {
                            msg_str.push_str(str)
                        }
                    }
                    ExpMessage::Error(str) => {
                        if self.config.4 > 1 {
                            msg_str.push_str(str)
                        }
                    }
                }
            }

            ui.add(
                TextEdit::multiline(&mut msg_str)
                    .desired_width(f32::INFINITY)
                    .desired_rows(4)
                    .font(egui::TextStyle::Monospace)
                    .interactive(false),
            );
        }

        fn show_logs_messages(&mut self, ui: &mut Ui, conf_struct: &mut ExpConfig) {
            let mut logs_str = String::new();
            //todo: don't show log button (replace self.config.2 but new config settings)
            if !self.config.2 {
                read_file_contents(conf_struct, &self.config.1, &mut logs_str, "log file");
            }

            ui.add(
                TextEdit::multiline(&mut logs_str)
                    .desired_width(f32::INFINITY)
                    .desired_rows(4)
                    .font(egui::TextStyle::Monospace)
                    .interactive(false),
            );
        }
    }

    pub fn start_gui() {
        let options = NativeOptions::default();
        run_native(
            "EXPLOITUS",
            options,
            Box::new(|_cc| Box::new(ExpGUI::default())),
        );
    }
}
